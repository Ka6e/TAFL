## 1. Циклы, ветвления, блоки кода

- **Go**: классическое структурное программирование, императивный стиль.
  ```
  for i := 0; i < 10; i++ {
      if i % 2 == 0 {
          fmt.Println("even")
      }
  }

- **Haskell**: нет привычных for/while. Повторение через рекурсию или функции высшего порядка (map, fold, iterate). Ветвления через if ... then ... else или case.

 ```
 mapM_ print [1..10]
    if x > 0 then "pos" else "neg"
 ```

⸻

## 2. Объявление переменных и параметров
- **Go**: явное или сокращённое объявление, тип после имени.

```
var x int = 5
y := 10
func add(a int, b int) int { return a + b }
```
- **Haskell**: переменные неизменяемые. Параметры задаются через сопоставление с образцом. Типы указываются до функции.

```
add :: Int -> Int -> Int
add a b = a + b
```

⸻

## 3. Набор типов данных

|Категория|Go|Haskell|
|-|--------|---|
|Целые|int, int8 … uint64|Int, Integer|
|Вещественные| float32, float64 | Float, Double|
|Логический| bool | Bool|
|Символ|rune (UTF-32) | Char|
|Строки|string (байты UTF-8) | [Char] или Text|
|Массив/список|[]T (срезы) | [a] (связанный список)|


⸻

# 4. Операторы
- **Go**: полный набор императивных операторов (++, --, +=, логические &&, ||, побитовые &, |, ^).
- **Haskell**: минимализм, всё выражения. Нет ++/--. Логика через &&, ||, побитовые операции через функции Data.Bits.

⸻

# 5. Пользовательские функции
- **Go**:
	•  Поддержка процедур и функций.
	•  Аргументы — передача по значению (структуры копируются).
	•  Рекурсия разрешена.
```
func fact(n int) int {
    if n <= 1 { return 1 }
    return n * fact(n-1)
}
```

- **Haskell**:
	•	Все функции чистые, нет процедур.
	•	Аргументы — по имени (ленивая семантика).
	•	Рекурсия — основной инструмент повторения.

```
fact :: Int -> Int
fact 0 = 1
fact n = n * fact (n - 1)
```

⸻

# 6. Пользовательские структуры
- **Go**: struct + методы.

```
type Point struct {
    X, Y int
}
func (p Point) Move(dx int) Point { return Point{p.X+dx, p.Y} }
```

- **Haskell**: algebraic data types.

```
data Point = Point { x :: Int, y :: Int }
move (Point x y) dx = Point (x+dx) y
```

⸻

# 7. Строки
- **Go**: неизменяемая последовательность байтов UTF-8. Есть отдельный тип rune для символов. Индексация и срезы возможны.
- **Haskell**: строка — список символов [Char]. Эффективный вариант — тип Text (lazy/strict). Нет прямой индексации, операции через рекурсию или стандартные функции.

⸻

# 8. Массивы и коллекции
- **Go**: массивы фиксированной длины [N]T, динамические срезы []T, встроенные словари map[K]V.
- **Haskell**: списки [a] как основной контейнер, массивы и векторы в библиотеках. Словари через Data.Map.

⸻

# 9. Управление памятью
- **Go**: сборщик мусора + возможность работать с указателями (&, *), но без арифметики указателей.
- **Haskell**: полный автомат, чисто функциональная модель, ссылки и мутация скрыты внутри IO или ST.

⸻

# 10. Обработка ошибок
- **Go**: идиома value, err := ..., явная проверка ошибок.
```
val, err := strconv.Atoi("123")
```

- **Haskell**: через Maybe, Either или исключения в IO.
```
case readMaybe \"123\" of
  Just n  -> print n
  Nothing -> putStrLn \"Ошибка\"
```